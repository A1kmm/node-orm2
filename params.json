{"name":"Object Relational Mapping","body":"## Install [![Build Status](https://secure.travis-ci.org/dresende/node-orm2.png)](http://travis-ci.org/dresende/node-orm2)\r\n\r\n```sh\r\nnpm install orm@2.0.0-alpha9\r\n```\r\n\r\nDespite the alpha tag, this is the recommended version for new applications.\r\n\r\n## DBMS Support\r\n\r\n- MySQL\r\n- PostgreSQL\r\n- SQLite\r\n\r\n## Features\r\n\r\n- Create Models, sync, drop, bulk create, get, find, remove, count\r\n- Create Model associations, find, check, create and remove\r\n- Define custom validations (several builtin validations, check instance properties before saving)\r\n- Instance singleton (table rows fetched twice are the same object, changes to one change all)\r\n\r\n## Introduction\r\n\r\nThis is a node.js object relational mapping module.\r\n\r\nHere is an example on how to use it:\r\n\r\n```js\r\nvar orm = require('orm');\r\n\r\norm.connect(\"mysql://username:password@host/database\", function (err, db) {\r\n\tif (err) throw err;\r\n\r\n\tvar Person = db.define('person', {\r\n\t\tname      : String,\r\n\t\tsurname   : String,\r\n\t\tage       : Number,\r\n\t\tmale      : Boolean,\r\n\t\tcontinent : [ 'Europe', 'America', 'Asia', 'Africa', 'Australia', 'Antartica' ], // ENUM type\r\n\t\tphoto     : Buffer, // BLOB/BINARY\r\n\t\tdata      : Object // JSON encoded\r\n\t}, {\r\n\t\tmethods: {\r\n\t\t\tfullName: function () {\r\n\t\t\t\treturn this.name + ' ' + this.surname;\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidations: {\r\n\t\t\tage: orm.validators.rangeNumber(18, undefined, 'under-age')\r\n\t\t}\r\n\t});\r\n\r\n\tPerson.find({ surname: \"Doe\" }, function (err, people) {\r\n\t\t// SQL: \"SELECT * FROM person WHERE surname = 'Doe'\"\r\n\r\n\t\tconsole.log(\"People found: %d\", people.length);\r\n\t\tconsole.log(\"First person: %s, age %d\", people[0].fullName(), people[0].age);\r\n\r\n\t\tpeople[0].age = 16;\r\n\t\tpeople[0].save(function (err) {\r\n\t\t\t// err.msg = 'under-age';\r\n\t\t});\r\n\t});\r\n});\r\n```\r\n\r\n## Models\r\n\r\nA Model is a structure binded to one or more tables, depending on the associations. The model name is assumed to be the table name. After defining a model you can use it to manipulate the table.\r\n\r\nAfter defining a Model you can get a specific element or find one or more based on some conditions.\r\n\r\n## Defining Models\r\n\r\nTo define a model, you use the reference to the database connection and call `define`. The function will define a Model\r\nand will return it to you. You can get it later by it's id directly from the database connection so you don't actually\r\nneed to store a reference to it.\r\n\r\n```js\r\nvar Person = db.define('person', {        // 'person' will be the table in the database as well as the model id\r\n\t// properties\r\n\tname    : String,                     // you can use native objects to define the property type\r\n\tsurname : { type: \"text\", size: 50 }  // or you can be specific and define aditional options\r\n}, {\r\n\t// options (optional)\r\n});\r\n```\r\n\r\n## Loading Models\r\n\r\nIf you prefer to have your models defined in separated files, you can define them in a function inside a module and\r\nexport the function has the entire module. You can have cascading loads.\r\n\r\n```js\r\n// your main file (after connecting)\r\ndb.load(\"./models\", function (err) {\r\n    // loaded!\r\n    var Person = db.models.person;\r\n    var Pet    = db.models.pet;\r\n});\r\n\r\n// models.js\r\nmodule.exports = function (db, cb) {\r\n    db.load(\"./models-extra\", function (err) {\r\n        if (err) {\r\n            return cb(err);\r\n        }\r\n\r\n        db.define('person', {\r\n            name : String\r\n        });\r\n\r\n        return cb();\r\n    });\r\n};\r\n\r\n// models-extra.js\r\nmodule.exports = function (db, cb) {\r\n    db.define('pet', {\r\n        name : String\r\n    });\r\n\r\n    return cb();\r\n};\r\n```\r\n\r\n## Synching Models\r\n\r\nIf you don't have the tables on the database you have to call the `.sync()` on every Model. This will just create the\r\ntables necessary for your Model. If you have more than one Model you can call `.sync()` directly on the database\r\nconnection to syncronize all Models.\r\n\r\n```js\r\n// db.sync() can also be used\r\nPerson.sync(function (err) {\r\n\t!err && console.log(\"done!\");\r\n});\r\n```\r\n\r\n## Dropping Models\r\n\r\nIf you want to drop a Model and remove all tables you can use the `.drop()` method.\r\n\r\n```js\r\nPerson.drop(function (err) {\r\n\t!err && console.log(\"person model no longer exists!\");\r\n});\r\n```\r\n\r\n## Finding Items\r\n\r\n### Model.get(id, [ options ], cb)\r\n\r\nTo get a specific element from the database use `Model.get`.\r\n\r\n```js\r\nPerson.get(123, function (err, person) {\r\n\t// finds person with id = 123\r\n});\r\n```\r\n\r\n### Model.find([ conditions ] [, options ] [, limit ] [, order ] [, cb ])\r\n\r\nFinding one or more elements has more options, each one can be given in no specific parameter order. Only `options` has to be after `conditions` (even if it's an empty object).\r\n\r\n```js\r\nPerson.find({ name: \"John\", surname: \"Doe\" }, 3, function (err, people) {\r\n\t// finds people with name='John' AND surname='Doe' and returns the first 3\r\n});\r\n```\r\n\r\nIf you need to sort the results because you're limiting or just because you want them sorted do:\r\n\r\n```js\r\nPerson.find({ surname: \"Doe\" }, \"name\", function (err, people) {\r\n\t// finds people with surname='Doe' and returns sorted by name ascending\r\n});\r\nPerson.find({ surname: \"Doe\" }, [ \"name\", \"Z\" ], function (err, people) {\r\n\t// finds people with surname='Doe' and returns sorted by name descending\r\n\t// ('Z' means DESC; 'A' means ASC - default)\r\n});\r\n```\r\n\r\nThere are more options that you can pass to find something. These options are passed in a second object:\r\n\r\n```js\r\nPerson.find({ surname: \"Doe\" }, { offset: 2 }, function (err, people) {\r\n\t// finds people with surname='Doe', skips the first 2 and returns the others\r\n});\r\n```\r\n\r\n### Model.count([ conditions, ] cb)\r\n\r\nIf you just want to count the number of items that match a condition you can just use `.count()` instead of finding all\r\nof them and counting. This will actually tell the database server to do a count, the count is not done in javascript.\r\n\r\n```js\r\nPerson.count({ surname: \"Doe\" }, function (err, count) {\r\n\tconsole.log(\"We have %d Does in our db\", count);\r\n});\r\n```\r\n\r\n### Model.exists([ conditions, ] cb)\r\n\r\nSimilar to `.count()`, this method just checks if the count is greater than zero or not.\r\n\r\n```js\r\nPerson.exists({ surname: \"Doe\" }, function (err, exists) {\r\n\tconsole.log(\"We %s Does in our db\", exists ? \"have\" : \"don't have\");\r\n});\r\n```\r\n\r\n#### Available options\r\n\r\n- `offset`: discards the first `N` elements\r\n- `limit`: although it can be passed as a direct argument, you can use it here if you prefer\r\n- `only`: if you don't want all properties, you can give an array with the list of properties you want\r\n\r\n#### Chaining\r\n\r\nIf you prefer another less complicated syntax you can chain `.find()` by not giving a callback parameter.\r\n\r\n```js\r\nPerson.find({ surname: \"Doe\" }).limit(3).offset(2).only(\"name\", \"surname\").run(function (err, people) {\r\n    // finds people with surname='Doe', skips first 2 and limits to 3 elements,\r\n    // returning only 'name' and 'surname' properties\r\n});\r\n```\r\n\r\nYou can also chain and just get the count in the end. In this case, offset, limit and order are ignored.\r\n\r\n```js\r\nPerson.find({ surname: \"Doe\" }).count(function (err, people) {\r\n    // people = number of people with surname=\"Doe\"\r\n});\r\n```\r\n\r\nAlso available is the option to remove the selected items.\r\n\r\n```js\r\nPerson.find({ surname: \"Doe\" }).remove(function (err) {\r\n    // Does gone..\r\n});\r\n```\r\n\r\n#### Conditions\r\n\r\nConditions are defined as an object where every key is a property (table column). All keys are supposed\r\nto be concatenated by the logical `AND`. Values are considered to match exactly, unless you're passing\r\nan `Array`. In this case it is considered a list to compare the property with.\r\n\r\n```js\r\n{ col1: 123, col2: \"foo\" } // `col1` = 123 AND `col2` = 'foo'\r\n{ col1: [ 1, 3, 5 ] } // `col1` IN (1, 3, 5)\r\n```\r\n\r\nIf you need other comparisons, you have to use a special object created by some helper functions. Here are\r\na few examples to describe it:\r\n\r\n```js\r\n{ col1: orm.eq(123) } // `col1` = 123 (default)\r\n{ col1: orm.ne(123) } // `col1` <> 123\r\n{ col1: orm.gt(123) } // `col1` > 123\r\n{ col1: orm.gte(123) } // `col1` >= 123\r\n{ col1: orm.lt(123) } // `col1` < 123\r\n{ col1: orm.lte(123) } // `col1` <= 123\r\n{ col1: orm.between(123, 456) } // `col1` BETWEEN 123 AND 456\r\n```\r\n\r\n## Associations\r\n\r\nAn association is a relation between one or more tables.\r\n\r\n## hasOne vs. hasMany Associations\r\n\r\nIf you have a relation of 1 to 0 or 1 to 1, you should use `hasOne` association. This assumes a column in the model that has the id of the other end of the relation.\r\n\r\n```js\r\nvar Person = db.define('person', {\r\n\tname : String\r\n});\r\nvar Animal = db.define('animal', {\r\n\tname : String\r\n});\r\nAnimal.hasOne(\"owner\", Person); // assumes column 'owner_id' in 'animal' table\r\n\r\n// get animal with id = 123\r\nAnimal.get(123, function (err, Foo) {\r\n\t// Foo is the animal model instance, if found\r\n\tFoo.getOwner(function (err, John) {\r\n\t\t// if Foo animal has really an owner, John points to it\r\n\t});\r\n});\r\n```\r\n\r\nFor relations of 1 to many you have to use `hasMany` associations. This assumes another table that has 2 columns, one for each table in the association.\r\n\r\n```js\r\nvar Person = db.define('person', {\r\n\tname : String\r\n});\r\nPerson.hasMany(\"friends\"); // omitting the other Model, it will assume self model\r\n\r\nPerson.get(123, function (err, John) {\r\n\tJohn.getFriends(function (err, friends) {\r\n\t\t// assumes table person_friends with columns person_id and friends_id\r\n\t});\r\n});\r\n```\r\n\r\nThe `hasMany` associations can have additional properties that are assumed to be in the association table.\r\n\r\n```js\r\nvar Person = db.define('person', {\r\n\tname : String\r\n});\r\nPerson.hasMany(\"friends\", {\r\n    rate : Number\r\n});\r\n\r\nPerson.get(123, function (err, John) {\r\n\tJohn.getFriends(function (err, friends) {\r\n\t\t// assumes rate is another column on table person_friends\r\n\t\t// you can access it by going to friends[N].extra.rate\r\n\t});\r\n});\r\n```\r\n\r\nIf you prefer you can activate `autoFetch`. This way associations are automatically fetched when you get or find instances of a model.\r\n\r\n```js\r\nvar Person = db.define('person', {\r\n\tname : String\r\n});\r\nPerson.hasMany(\"friends\", {\r\n    rate : Number\r\n}, {\r\n    autoFetch : true\r\n});\r\n\r\nPerson.get(123, function (err, John) {\r\n    // no need to do John.getFriends() , John already has John.friends Array\r\n});\r\n```\r\n\r\nYou can also define this option globally instead of a per association basis.\r\n\r\n```js\r\nvar Person = db.define('person', {\r\n\tname : String\r\n}, {\r\n    autoFetch : true\r\n});\r\nPerson.hasMany(\"friends\", {\r\n    rate : Number\r\n});\r\n```","tagline":"For NodeJS","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-36807397-1"}